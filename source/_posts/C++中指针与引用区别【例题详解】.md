C++中指针与引用区别【例题详解】

C++引用与指针的比较  
原始地址： [ http://www.cnblogs.com/kingln/archive/2008/03/29/1129118.html
](http://www.cnblogs.com/kingln/archive/2008/03/29/1129118.html)

  
引用是C++中的概念，初学者容易把引用和指针混淆一起。  
以下程序中，n是m的一个引用（reference），m是被引用物（referent）。  
int m;  
int &n = m;  
n相当于m的别名（绰号），对n的任何操作就是对m的操作。  
所以n既不是m的拷贝，也不是指向m的指针，其实n就是m它自己。  
  
引用的规则：  
  
（1）引用被创建的同时必须被初始化（指针则可以在任何时候被初始化）。  
（2）不能有NULL引用，引用必须与合法的存储单元关联（指针则可以是NULL）。  
（3）一旦引用被初始化，就不能改变引用的关系（指针则可以随时改变所指的对象）。  
  
以下示例程序中，k被初始化为i的引用。  
语句k = j并不能将k修改成为j的引用，只是把k的值改变成为6。  
由于k是i的引用，所以i的值也变成了6。  
int i = 5;  
int j = 6;  
int &k = i;  
k = j; // k和i的值都变成了6;  
  
引用的主要功能是传递函数的参数和返回值。  
  
C++语言中，函数的参数和返回值的传递方式有三种：值传递、指针传递和引用传递。  
  
以下是"值传递"的示例程序。  
  
由于Func1函数体内的x是外部变量n的一份拷贝，改变x的值不会影响n, 所以n的值仍然是0。  
void Func1(int x)  
{  
x = x + 10;  
}  
...  
int n = 0;  
Func1(n);  
cout << "n = " << n << endl; // n = 0  
  
以下是"指针传递"的示例程序。  
  
由于Func2函数体内的x是指向外部变量n的指针，改变该指针的内容将导致n的值改变，所以n的值成为10。  
void Func2(int *x)  
{  
(* x) = (* x) + 10;  
}  
...  
int n = 0;  
Func2(&n);  
cout << "n = " << n << endl; // n = 10  
  
以下是"引用传递"的示例程序。  
  
由于Func3函数体内的x是外部变量n的引用，x和n是同一个东西，改变x等于改变n，所以n的值成为10。  
void Func3(int &x)  
{  
x = x + 10;  
}  
...  
int n = 0;  
Func3(n);  
cout << "n = " << n << endl; // n = 10  
  
对比上述三个示例程序，会发现"引用传递"的性质象"指针传递"，而书写方式象"值传递"。  
  
实际上"引用"可以做的任何事情"指针"也都能够做，为什么还要"引用"这东西？  
答案是"用适当的工具做恰如其分的工作"。  
  
指针能够毫无约束地操作内存中的任何东西，尽管指针功能强大，但是非常危险。  
  
如果的确只需要借用一下某个对象的"别名"，那么就用"引用"，而不要用"指针"，以免发生意外。

