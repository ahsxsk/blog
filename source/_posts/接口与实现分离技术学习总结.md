title: 接口与实现分离技术学习总结
date: 2016-11-11 13:09:04
tags: [学习]
------------------
前一段时间遇到接口与实现分离问题的时候才发现自己对这个问题一直处于迷糊状态。今天在网上找了篇博文学习了下。

原博文地址 [ 点击打开链接 ](http://blog.csdn.net/starlee/article/details/610825)
http://blog.csdn.net/starlee/article/details/610825。

结合自己的理解，写了篇学习小结。

    
    
    /*
    *“接口与实现学习总结”
    */
    
    /*
    *首先写一个没有实现接口与实现分离的例子，然后分析它的缺点。
    *在头文件中定义一个类，在cpp文件中给出具体实现。
    */
    
    //student.h
    class Student
    {
    	public:
    		Student();
    		virtual ~Student();
    		void eat();
    	private:
    		void eatstep();
    }
    
    //student.cpp
    #include "student.h"
    Student::Student() 
    {
    }
    
    Student::~Student()
    {
    }
    
    void Student::eat()
    {
    	eatstep();
    }
    
    /*
    *现在考虑，我们将student.h作为接口提供给用户会发生什么？
    *Student的私有成员全部暴漏给用户了，这是我们所不希望的。
    **************************************************************
    *如果我们在Student类中还定义了其他类的变量，情况就会更糟糕。
    */
    
    //person.h
    class Person()
    {
    	public:
    		Person();
    		virtual ~Person();
    		void sleep();
    }
    
    /*
    *person.cpp省略
    ******************************************************
    *现在在Student的private中添加一个Person对象
    */
    //student.h
    #include "person.h"
    class Student
    {
    	public:
    		Student();
    		virtual ~Student();
    		void eat();
    	private:
    		void eatstep();
    		Person person;
    }
    
    //student.cpp
    #include "student.h"
    Student::Student() 
    {
    }
    
    Student::~Student()
    {
    }
    
    void Student::eat()
    {	
    	//睡醒后吃早饭，并没有太强的逻辑关系
    	person.sleep();
    	eatstep();
    }
    
    /*
    *现在我们将student.h提供出去。更不好的事情就会发生。
    *不仅仅Student类的私有变量会暴漏，由于包含了person.h，Person类的私有变量也会被暴露。
    *更进一步的如果我们修改Person类，那我们必须给用户更新person.h。但是person.h并不是用户所
    *需要的接口，用户仅仅需要的事Student.h。
    *************************************************************************************
    *为了改变这些现状，我们采用接口与实现分离的技术
    *我们要定义两个类，接口类和实现类。这两个类拥有相同的成员函数，因为他们要实现同样的接口功能。
    */
    //实现类头文件stuimplement.h
    #include "person.h"
    class Stuimplement
    {
    	public:
    		Stuimplement();
    		virtual ~Stuimplement();
    		void eat();
    	private:
    		void eatstep();
    		Person person;
    }
    
    //实现类定义函数文件stuimplement.cpp
    #include "stuimplement.h"
    Stuimplement::Stuimplement() 
    {
    }
    
    Stuimplement::~Stuimplement()
    {
    }
    
    void Stuimplement::eat()
    {	
    	//睡醒后吃早饭，并没有太强的逻辑关系
    	person.sleep();
    	eatstep();
    }
    
    //接口类声明头文件student.h
    
    //实现类前向声明
    class Stuimplement;
    class Student
    {
    	public:
    		Student();
    		virtual ~Student();
    		void eat();
    	private:
    		//定义一个实现类的指针
    		Stuimplement * Stuimpl;
    }
    
    //接口类定义文件student.cpp
    #include "student.h"
    #include "stuimplement.h"
    Student::Student() 
    {
    	impl = new Stuimplement;
    }
    
    Student::~Student()
    {
    	if(impl)
    		delete impl;
    }
    
    void Student::eat()
    {	
    	//睡醒后吃早饭，并没有太强的逻辑关系
    	impl->person.sleep();
    	impl->eat();
    }
    
    /*这样我们将修改后的student.h的作为接口提供出去将不会暴露任何实现细节*/

  

